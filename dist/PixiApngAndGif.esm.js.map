{"version":3,"file":"PixiApngAndGif.esm.js","sources":["../src/lib/_omggif.ts","../src/lib/_upng.ts","../src/PixiApngAndGif.ts","../src/lib/_getExeName.ts"],"sourcesContent":["// (c) Dean McNamee <dean@gmail.com>, 2013.\r\n//\r\n// https://github.com/deanm/omggif\r\n//\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n// of this software and associated documentation files (the \"Software\"), to\r\n// deal in the Software without restriction, including without limitation the\r\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n// sell copies of the Software, and to permit persons to whom the Software is\r\n// furnished to do so, subject to the following conditions:\r\n//\r\n// The above copyright notice and this permission notice shall be included in\r\n// all copies or substantial portions of the Software.\r\n//\r\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n// IN THE SOFTWARE.\r\n//\r\n// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\r\n// including animation and compression.  It does not rely on any specific\r\n// underlying system, so should run in the browser, Node, or Plask.\r\n\r\n\"use strict\";\r\n\r\nclass GifReader {\r\n\r\n  private frames: Array<\r\n      {\r\n        x: number;\r\n        y: number;\r\n        width: number;\r\n        height: number;\r\n        has_local_palette: boolean;\r\n        palette_offset: number | null;\r\n        palette_size: number | null;\r\n        data_offset: number;\r\n        data_length: number;\r\n        transparent_index: number | null;\r\n        interlaced: boolean;\r\n        delay: number;\r\n        disposal: number;\r\n      }> = [];\r\n\r\n  private loop_count: number | null = null;\r\n  private buf: Uint8Array;\r\n  width: number;\r\n  height: number;\r\n\r\n  constructor(buf: Uint8Array) {\r\n    this.buf = buf;\r\n    let p = 0;\r\n\r\n    // - Header (GIF87a or GIF89a).\r\n    if (buf[p++] !== 0x47 || buf[p++] !== 0x49 || buf[p++] !== 0x46 ||\r\n        buf[p++] !== 0x38 || (buf[p++] + 1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {\r\n      throw new Error(\"Invalid GIF 87a/89a header.\");\r\n    }\r\n\r\n    // - Logical Screen Descriptor.\r\n    var width = buf[p++] | buf[p++] << 8;\r\n    var height = buf[p++] | buf[p++] << 8;\r\n    var pf0 = buf[p++]; // <Packed Fields>.\r\n    var global_palette_flag = pf0 >> 7;\r\n    var num_global_colors_pow2 = pf0 & 0x7;\r\n    var num_global_colors = 1 << (num_global_colors_pow2 + 1);\r\n    var background = buf[p++];\r\n    buf[p++]; // Pixel aspect ratio (unused?).\r\n\r\n    var global_palette_offset = null;\r\n    var global_palette_size = null;\r\n\r\n    if (global_palette_flag) {\r\n      global_palette_offset = p;\r\n      global_palette_size = num_global_colors;\r\n      p += num_global_colors * 3; // Seek past palette.\r\n    }\r\n\r\n    var no_eof = true;\r\n\r\n    var delay = 0;\r\n    var transparent_index = null;\r\n    var disposal = 0; // 0 - No disposal specified.\r\n\r\n    this.width = width;\r\n    this.height = height;\r\n\r\n    while (no_eof && p < buf.length) {\r\n      switch (buf[p++]) {\r\n        case 0x21: // Graphics Control Extension Block\r\n          switch (buf[p++]) {\r\n            case 0xff: // Application specific block\r\n              // Try if it's a Netscape block (with animation loop counter).\r\n              if (buf[p] !== 0x0b || // 21 FF already read, check block size.\r\n                  // NETSCAPE2.0\r\n                  buf[p + 1] == 0x4e && buf[p + 2] == 0x45 && buf[p + 3] == 0x54 &&\r\n                  buf[p + 4] == 0x53 && buf[p + 5] == 0x43 && buf[p + 6] == 0x41 &&\r\n                  buf[p + 7] == 0x50 && buf[p + 8] == 0x45 && buf[p + 9] == 0x32 &&\r\n                  buf[p + 10] == 0x2e && buf[p + 11] == 0x30 &&\r\n                  // Sub-block\r\n                  buf[p + 12] == 0x03 && buf[p + 13] == 0x01 && buf[p + 16] == 0) {\r\n                p += 14;\r\n                this.loop_count = buf[p++] | buf[p++] << 8;\r\n                p++; // Skip terminator.\r\n              } else { // We don't know what it is, just try to get past it.\r\n                p += 12;\r\n                while (true) { // Seek through subblocks.\r\n                  var block_size = buf[p++];\r\n                  // Bad block size (ex: undefined from an out of bounds read).\r\n                  if (!(block_size >= 0)) throw Error(\"Invalid block size\");\r\n                  if (block_size === 0) break; // 0 size is terminator\r\n                  p += block_size;\r\n                }\r\n              }\r\n              break;\r\n\r\n            case 0xf9: // Graphics Control Extension\r\n              if (buf[p++] !== 0x4 || buf[p + 4] !== 0)\r\n                throw new Error(\"Invalid graphics extension block.\");\r\n              var pf1 = buf[p++];\r\n              delay = buf[p++] | buf[p++] << 8;\r\n              transparent_index = buf[p++];\r\n              if ((pf1 & 1) === 0) transparent_index = null;\r\n              disposal = pf1 >> 2 & 0x7;\r\n              p++; // Skip terminator.\r\n              break;\r\n\r\n            case 0xfe: // Comment Extension.\r\n              while (true) { // Seek through subblocks.\r\n                var block_size = buf[p++];\r\n                // Bad block size (ex: undefined from an out of bounds read).\r\n                if (!(block_size >= 0)) throw Error(\"Invalid block size\");\r\n                if (block_size === 0) break; // 0 size is terminator\r\n                // console.log(buf.slice(p, p+block_size).toString('ascii'));\r\n                p += block_size;\r\n              }\r\n              break;\r\n\r\n            default:\r\n              throw new Error(\r\n                  \"Unknown graphic control label: 0x\" + buf[p - 1].toString(16));\r\n          }\r\n          break;\r\n\r\n        case 0x2c: // Image Descriptor.\r\n          var x = buf[p++] | buf[p++] << 8;\r\n          var y = buf[p++] | buf[p++] << 8;\r\n          var w = buf[p++] | buf[p++] << 8;\r\n          var h = buf[p++] | buf[p++] << 8;\r\n          var pf2 = buf[p++];\r\n          var local_palette_flag = pf2 >> 7;\r\n          var interlace_flag = pf2 >> 6 & 1;\r\n          var num_local_colors_pow2 = pf2 & 0x7;\r\n          var num_local_colors = 1 << (num_local_colors_pow2 + 1);\r\n          var palette_offset = global_palette_offset;\r\n          var palette_size = global_palette_size;\r\n          var has_local_palette = false;\r\n          if (local_palette_flag) {\r\n            var has_local_palette = true;\r\n            palette_offset = p; // Override with local palette.\r\n            palette_size = num_local_colors;\r\n            p += num_local_colors * 3; // Seek past palette.\r\n          }\r\n\r\n          var data_offset = p;\r\n\r\n          p++; // codesize\r\n          while (true) {\r\n            var block_size = buf[p++];\r\n            // Bad block size (ex: undefined from an out of bounds read).\r\n            if (!(block_size >= 0)) throw Error(\"Invalid block size\");\r\n            if (block_size === 0) break; // 0 size is terminator\r\n            p += block_size;\r\n          }\r\n\r\n          this.frames.push({\r\n            x: x,\r\n            y: y,\r\n            width: w,\r\n            height: h,\r\n            has_local_palette: has_local_palette,\r\n            palette_offset: palette_offset,\r\n            palette_size: palette_size,\r\n            data_offset: data_offset,\r\n            data_length: p - data_offset,\r\n            transparent_index: transparent_index,\r\n            interlaced: !!interlace_flag,\r\n            delay: delay,\r\n            disposal: disposal\r\n          });\r\n          break;\r\n\r\n        case 0x3b: // Trailer Marker (end of file).\r\n          no_eof = false;\r\n          break;\r\n\r\n        default:\r\n          throw new Error(\"Unknown gif block: 0x\" + buf[p - 1].toString(16));\r\n          break;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n\r\n  numFrames() {\r\n    return this.frames.length;\r\n  };\r\n\r\n  private loopCount() {\r\n    return this.loop_count;\r\n  };\r\n\r\n  frameInfo(frame_num: number) {\r\n    if (frame_num < 0 || frame_num >= this.frames.length)\r\n      throw new Error(\"Frame index out of range.\");\r\n    return this.frames[frame_num];\r\n  }\r\n\r\n  private decodeAndBlitFrameBGRA(frame_num: number, pixels: Uint8Array) {\r\n    var frame = this.frameInfo(frame_num);\r\n    var num_pixels = frame.width * frame.height;\r\n    var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.\r\n    GifReaderLZWOutputIndexStream(\r\n      this.buf, frame.data_offset, index_stream, num_pixels);\r\n    var palette_offset = frame.palette_offset as number;\r\n\r\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\r\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\r\n    // the profile, not sure if it's related to using a Uint8Array.\r\n    var trans = frame.transparent_index;\r\n    if (trans === null) trans = 256;\r\n\r\n    // We are possibly just blitting to a portion of the entire frame.\r\n    // That is a subrect within the framerect, so the additional pixels\r\n    // must be skipped over after we finished a scanline.\r\n    var framewidth = frame.width;\r\n    var framestride = this.width - framewidth;\r\n    var xleft = framewidth; // Number of subrect pixels left in scanline.\r\n\r\n    // Output indicies of the top left and bottom right corners of the subrect.\r\n    var opbeg = ((frame.y * this.width) + frame.x) * 4;\r\n    var opend = ((frame.y + frame.height) * this.width + frame.x) * 4;\r\n    var op = opbeg;\r\n\r\n    var scanstride = framestride * 4;\r\n\r\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\r\n    // 7 rows for the first two passes, then 3 then 1.\r\n    if (frame.interlaced === true) {\r\n      scanstride += this.width * 4 * 7; // Pass 1.\r\n    }\r\n\r\n    var interlaceskip = 8; // Tracking the row interval in the current pass.\r\n\r\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\r\n      var index = index_stream[i];\r\n\r\n      if (xleft === 0) { // Beginning of new scan line\r\n        op += scanstride;\r\n        xleft = framewidth;\r\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\r\n          scanstride = framestride * 4 + this.width * 4 * (interlaceskip - 1);\r\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\r\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\r\n          interlaceskip >>= 1;\r\n        }\r\n      }\r\n\r\n      if (index === trans) {\r\n        op += 4;\r\n      } else {\r\n        var r = this.buf[palette_offset + index * 3];\r\n        var g = this.buf[palette_offset + index * 3 + 1];\r\n        var b = this.buf[palette_offset + index * 3 + 2];\r\n        pixels[op++] = b;\r\n        pixels[op++] = g;\r\n        pixels[op++] = r;\r\n        pixels[op++] = 255;\r\n      }\r\n      --xleft;\r\n    }\r\n  };\r\n\r\n  // I will go to copy and paste hell one day...\r\n  decodeAndBlitFrameRGBA(frame_num: number, pixels: Array<number>) {\r\n    var frame = this.frameInfo(frame_num);\r\n    var num_pixels = frame.width * frame.height;\r\n    var index_stream = new Uint8Array(num_pixels); // At most 8-bit indices.\r\n    GifReaderLZWOutputIndexStream(\r\n      this.buf, frame.data_offset, index_stream, num_pixels);\r\n    var palette_offset = frame.palette_offset as number;\r\n\r\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\r\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\r\n    // the profile, not sure if it's related to using a Uint8Array.\r\n    var trans = frame.transparent_index;\r\n    if (trans === null) trans = 256;\r\n\r\n    // We are possibly just blitting to a portion of the entire frame.\r\n    // That is a subrect within the framerect, so the additional pixels\r\n    // must be skipped over after we finished a scanline.\r\n    var framewidth = frame.width;\r\n    var framestride = this.width - framewidth;\r\n    var xleft = framewidth; // Number of subrect pixels left in scanline.\r\n\r\n    // Output indicies of the top left and bottom right corners of the subrect.\r\n    var opbeg = ((frame.y * this.width) + frame.x) * 4;\r\n    var opend = ((frame.y + frame.height) * this.width + frame.x) * 4;\r\n    var op = opbeg;\r\n\r\n    var scanstride = framestride * 4;\r\n\r\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\r\n    // 7 rows for the first two passes, then 3 then 1.\r\n    if (frame.interlaced === true) {\r\n      scanstride += this.width * 4 * 7; // Pass 1.\r\n    }\r\n\r\n    var interlaceskip = 8; // Tracking the row interval in the current pass.\r\n\r\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\r\n      var index = index_stream[i];\r\n\r\n      if (xleft === 0) { // Beginning of new scan line\r\n        op += scanstride;\r\n        xleft = framewidth;\r\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\r\n          scanstride = framestride * 4 + this.width * 4 * (interlaceskip - 1);\r\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\r\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\r\n          interlaceskip >>= 1;\r\n        }\r\n      }\r\n\r\n      if (index === trans) {\r\n        op += 4;\r\n      } else {\r\n        var r = this.buf[palette_offset + index * 3];\r\n        var g = this.buf[palette_offset + index * 3 + 1];\r\n        var b = this.buf[palette_offset + index * 3 + 2];\r\n        pixels[op++] = r;\r\n        pixels[op++] = g;\r\n        pixels[op++] = b;\r\n        pixels[op++] = 255;\r\n      }\r\n      --xleft;\r\n    }\r\n  };\r\n}\r\n\r\nfunction GifReaderLZWOutputIndexStream(code_stream: Uint8Array, p: number, output: Uint8Array, output_length: number) {\r\n  var min_code_size = code_stream[p++];\r\n\r\n  var clear_code = 1 << min_code_size;\r\n  var eoi_code = clear_code + 1;\r\n  var next_code = eoi_code + 1;\r\n\r\n  var cur_code_size = min_code_size + 1; // Number of bits per code.\r\n  // NOTE: This shares the same name as the encoder, but has a different\r\n  // meaning here.  Here this masks each code coming from the code stream.\r\n  var code_mask = (1 << cur_code_size) - 1;\r\n  var cur_shift = 0;\r\n  var cur = 0;\r\n\r\n  var op = 0; // Output pointer.\r\n\r\n  var subblock_size = code_stream[p++];\r\n\r\n  // TODO(deanm): Would using a TypedArray be any faster?  At least it would\r\n  // solve the fast mode / backing store uncertainty.\r\n  // var code_table = Array(4096);\r\n  var code_table = new Int32Array(4096); // Can be signed, we only use 20 bits.\r\n\r\n  var prev_code = null; // Track code-1.\r\n\r\n  while (true) {\r\n    // Read up to two bytes, making sure we always 12-bits for max sized code.\r\n    while (cur_shift < 16) {\r\n      if (subblock_size === 0) break; // No more data to be read.\r\n\r\n      cur |= code_stream[p++] << cur_shift;\r\n      cur_shift += 8;\r\n\r\n      if (subblock_size === 1) { // Never let it get to 0 to hold logic above.\r\n        subblock_size = code_stream[p++]; // Next subblock.\r\n      } else {\r\n        --subblock_size;\r\n      }\r\n    }\r\n\r\n    // TODO(deanm): We should never really get here, we should have received\r\n    // and EOI.\r\n    if (cur_shift < cur_code_size)\r\n      break;\r\n\r\n    var code = cur & code_mask;\r\n    cur >>= cur_code_size;\r\n    cur_shift -= cur_code_size;\r\n\r\n    // TODO(deanm): Maybe should check that the first code was a clear code,\r\n    // at least this is what you're supposed to do.  But actually our encoder\r\n    // now doesn't emit a clear code first anyway.\r\n    if (code === clear_code) {\r\n      // We don't actually have to clear the table.  This could be a good idea\r\n      // for greater error checking, but we don't really do any anyway.  We\r\n      // will just track it with next_code and overwrite old entries.\r\n\r\n      next_code = eoi_code + 1;\r\n      cur_code_size = min_code_size + 1;\r\n      code_mask = (1 << cur_code_size) - 1;\r\n\r\n      // Don't update prev_code ?\r\n      prev_code = null;\r\n      continue;\r\n    } else if (code === eoi_code) {\r\n      break;\r\n    }\r\n\r\n    // We have a similar situation as the decoder, where we want to store\r\n    // variable length entries (code table entries), but we want to do in a\r\n    // faster manner than an array of arrays.  The code below stores sort of a\r\n    // linked list within the code table, and then \"chases\" through it to\r\n    // construct the dictionary entries.  When a new entry is created, just the\r\n    // last byte is stored, and the rest (prefix) of the entry is only\r\n    // referenced by its table entry.  Then the code chases through the\r\n    // prefixes until it reaches a single byte code.  We have to chase twice,\r\n    // first to compute the length, and then to actually copy the data to the\r\n    // output (backwards, since we know the length).  The alternative would be\r\n    // storing something in an intermediate stack, but that doesn't make any\r\n    // more sense.  I implemented an approach where it also stored the length\r\n    // in the code table, although it's a bit tricky because you run out of\r\n    // bits (12 + 12 + 8), but I didn't measure much improvements (the table\r\n    // entries are generally not the long).  Even when I created benchmarks for\r\n    // very long table entries the complexity did not seem worth it.\r\n    // The code table stores the prefix entry in 12 bits and then the suffix\r\n    // byte in 8 bits, so each entry is 20 bits.\r\n\r\n    var chase_code: number | null = code < next_code ? code : prev_code;\r\n\r\n    // Chase what we will output, either {CODE} or {CODE-1}.\r\n    var chase_length = 0;\r\n    var chase = chase_code as number;\r\n    while (chase > clear_code) {\r\n      chase = code_table[chase] >> 8;\r\n      ++chase_length;\r\n    }\r\n\r\n    var k = chase;\r\n\r\n    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);\r\n    if (op_end > output_length) {\r\n      console.log(\"Warning, gif stream longer than expected.\");\r\n      return;\r\n    }\r\n\r\n    // Already have the first byte from the chase, might as well write it fast.\r\n    output[op++] = k;\r\n\r\n    op += chase_length;\r\n    var b = op; // Track pointer, writing backwards.\r\n\r\n    if (chase_code !== code) // The case of emitting {CODE-1} + k.\r\n      output[op++] = k;\r\n\r\n    chase = chase_code as number;\r\n    while (chase_length--) {\r\n      chase = code_table[chase];\r\n      output[--b] = chase & 0xff; // Write backwards.\r\n      chase >>= 8; // Pull down to the prefix code.\r\n    }\r\n\r\n    if (prev_code !== null && next_code < 4096) {\r\n      code_table[next_code++] = prev_code << 8 | k;\r\n      // TODO(deanm): Figure out this clearing vs code growth logic better.  I\r\n      // have an feeling that it should just happen somewhere else, for now it\r\n      // is awkward between when we grow past the max and then hit a clear code.\r\n      // For now just check if we hit the max 12-bits (then a clear code should\r\n      // follow, also of course encoded in 12-bits).\r\n      if (next_code >= code_mask + 1 && cur_code_size < 12) {\r\n        ++cur_code_size;\r\n        code_mask = code_mask << 1 | 1;\r\n      }\r\n    }\r\n\r\n    prev_code = code;\r\n  }\r\n\r\n  if (op !== output_length) {\r\n    console.log(\"Warning, gif stream shorter than expected.\");\r\n  }\r\n\r\n  return output;\r\n}\r\n\r\nexport {GifReader as $omggif};\r\n","import * as pako from 'pako'\r\n\r\nif (Uint8Array && !Uint8Array.prototype.slice) {\r\n    Uint8Array.prototype.slice = function (...arg) {\r\n        return new Uint8Array(this).subarray(...arg);\r\n    };\r\n}\r\n\r\nexport function uPng(out) {\r\n    let w = out.width,\r\n        h = out.height;\r\n    if (out.tabs.acTL == null) return [toRGBA8.decodeImage(out.data, w, h, out).buffer];\r\n\r\n    let frms = [];\r\n    if (out.frames[0].data == null) out.frames[0].data = out.data;\r\n\r\n    let img, empty = new Uint8Array(w * h * 4);\r\n    for (let i = 0; i < out.frames.length; i++) {\r\n        let frm = out.frames[i];\r\n        let fx = frm.rect.x,\r\n            fy = frm.rect.y,\r\n            fw = frm.rect.width,\r\n            fh = frm.rect.height;\r\n        let fdata = toRGBA8.decodeImage(frm.data, fw, fh, out);\r\n\r\n        if (i == 0) img = fdata;\r\n        else if (frm.blend == 0) _copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);\r\n        else if (frm.blend == 1) _copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\r\n\r\n        frms.push(img.buffer);\r\n        img = img.slice(0);\r\n\r\n        if (frm.dispose == 0) {\r\n        } else if (frm.dispose == 1) _copyTile(empty, fw, fh, img, w, h, fx, fy, 0);\r\n        else if (frm.dispose == 2) {\r\n            let pi = i - 1;\r\n            while (out.frames[pi].dispose == 2) pi--;\r\n            img = new Uint8Array(frms[pi]).slice(0);\r\n        }\r\n    }\r\n    return frms;\r\n}\r\n\r\nclass toRGBA8 {\r\n    static decodeImage(data, w, h, out) {\r\n        let area = w * h,\r\n            bpp = decode._getBPP(out);\r\n        let bpl = Math.ceil(w * bpp / 8); // bytes per line\r\n        let bf = new Uint8Array(area * 4),\r\n            bf32 = new Uint32Array(bf.buffer);\r\n        let ctype = out.ctype,\r\n            depth = out.depth;\r\n        let rs = _bin.readUshort;\r\n\r\n        //console.log(ctype, depth);\r\n        if (ctype == 6) { // RGB + alpha\r\n            let qarea = area << 2;\r\n            if (depth == 8)\r\n                for (let i = 0; i < qarea; i++) {\r\n                    bf[i] = data[i];\r\n                    /*if((i&3)==3 && data[i]!=0) bf[i]=255;*/\r\n                }\r\n            if (depth == 16)\r\n                for (let i = 0; i < qarea; i++) {\r\n                    bf[i] = data[i << 1];\r\n                }\r\n        } else if (ctype == 2) { // RGB\r\n            let ts = out.tabs[\"tRNS\"],\r\n                tr = -1,\r\n                tg = -1,\r\n                tb = -1;\r\n            if (ts) {\r\n                tr = ts[0];\r\n                tg = ts[1];\r\n                tb = ts[2];\r\n            }\r\n            if (depth == 8)\r\n                for (let i = 0; i < area; i++) {\r\n                    let qi = i << 2,\r\n                        ti = i * 3;\r\n                    bf[qi] = data[ti];\r\n                    bf[qi + 1] = data[ti + 1];\r\n                    bf[qi + 2] = data[ti + 2];\r\n                    bf[qi + 3] = 255;\r\n                    if (tr != -1 && data[ti] == tr && data[ti + 1] == tg && data[ti + 2] == tb) bf[qi + 3] = 0;\r\n                }\r\n            if (depth == 16)\r\n                for (let i = 0; i < area; i++) {\r\n                    let qi = i << 2,\r\n                        ti = i * 6;\r\n                    bf[qi] = data[ti];\r\n                    bf[qi + 1] = data[ti + 2];\r\n                    bf[qi + 2] = data[ti + 4];\r\n                    bf[qi + 3] = 255;\r\n                    if (tr != -1 && rs(data, ti) == tr && rs(data, ti + 2) == tg && rs(data, ti + 4) == tb) bf[qi + 3] = 0;\r\n                }\r\n        } else if (ctype == 3) { // palette\r\n            let p = out.tabs[\"PLTE\"],\r\n                ap = out.tabs[\"tRNS\"],\r\n                tl = ap ? ap.length : 0;\r\n            //console.log(p, ap);\r\n            if (depth == 1)\r\n                for (let y = 0; y < h; y++) {\r\n                    let s0 = y * bpl,\r\n                        t0 = y * w;\r\n                    for (let i = 0; i < w; i++) {\r\n                        let qi = (t0 + i) << 2,\r\n                            j = ((data[s0 + (i >> 3)] >> (7 - ((i & 7) << 0))) & 1),\r\n                            cj = 3 * j;\r\n                        bf[qi] = p[cj];\r\n                        bf[qi + 1] = p[cj + 1];\r\n                        bf[qi + 2] = p[cj + 2];\r\n                        bf[qi + 3] = (j < tl) ? ap[j] : 255;\r\n                    }\r\n                }\r\n            if (depth == 2)\r\n                for (let y = 0; y < h; y++) {\r\n                    let s0 = y * bpl,\r\n                        t0 = y * w;\r\n                    for (let i = 0; i < w; i++) {\r\n                        let qi = (t0 + i) << 2,\r\n                            j = ((data[s0 + (i >> 2)] >> (6 - ((i & 3) << 1))) & 3),\r\n                            cj = 3 * j;\r\n                        bf[qi] = p[cj];\r\n                        bf[qi + 1] = p[cj + 1];\r\n                        bf[qi + 2] = p[cj + 2];\r\n                        bf[qi + 3] = (j < tl) ? ap[j] : 255;\r\n                    }\r\n                }\r\n            if (depth == 4)\r\n                for (let y = 0; y < h; y++) {\r\n                    let s0 = y * bpl,\r\n                        t0 = y * w;\r\n                    for (let i = 0; i < w; i++) {\r\n                        let qi = (t0 + i) << 2,\r\n                            j = ((data[s0 + (i >> 1)] >> (4 - ((i & 1) << 2))) & 15),\r\n                            cj = 3 * j;\r\n                        bf[qi] = p[cj];\r\n                        bf[qi + 1] = p[cj + 1];\r\n                        bf[qi + 2] = p[cj + 2];\r\n                        bf[qi + 3] = (j < tl) ? ap[j] : 255;\r\n                    }\r\n                }\r\n            if (depth == 8)\r\n                for (let i = 0; i < area; i++) {\r\n                    let qi = i << 2,\r\n                        j = data[i],\r\n                        cj = 3 * j;\r\n                    bf[qi] = p[cj];\r\n                    bf[qi + 1] = p[cj + 1];\r\n                    bf[qi + 2] = p[cj + 2];\r\n                    bf[qi + 3] = (j < tl) ? ap[j] : 255;\r\n                }\r\n        } else if (ctype == 4) { // gray + alpha\r\n            if (depth == 8)\r\n                for (let i = 0; i < area; i++) {\r\n                    let qi = i << 2,\r\n                        di = i << 1,\r\n                        gr = data[di];\r\n                    bf[qi] = gr;\r\n                    bf[qi + 1] = gr;\r\n                    bf[qi + 2] = gr;\r\n                    bf[qi + 3] = data[di + 1];\r\n                }\r\n            if (depth == 16)\r\n                for (let i = 0; i < area; i++) {\r\n                    let qi = i << 2,\r\n                        di = i << 2,\r\n                        gr = data[di];\r\n                    bf[qi] = gr;\r\n                    bf[qi + 1] = gr;\r\n                    bf[qi + 2] = gr;\r\n                    bf[qi + 3] = data[di + 2];\r\n                }\r\n        } else if (ctype == 0) { // gray\r\n            let tr = out.tabs[\"tRNS\"] ? out.tabs[\"tRNS\"] : -1;\r\n            if (depth == 1)\r\n                for (let i = 0; i < area; i++) {\r\n                    let gr = 255 * ((data[i >> 3] >> (7 - ((i & 7)))) & 1),\r\n                        al = (gr == tr * 255) ? 0 : 255;\r\n                    bf32[i] = (al << 24) | (gr << 16) | (gr << 8) | gr;\r\n                }\r\n            if (depth == 2)\r\n                for (let i = 0; i < area; i++) {\r\n                    let gr = 85 * ((data[i >> 2] >> (6 - ((i & 3) << 1))) & 3),\r\n                        al = (gr == tr * 85) ? 0 : 255;\r\n                    bf32[i] = (al << 24) | (gr << 16) | (gr << 8) | gr;\r\n                }\r\n            if (depth == 4)\r\n                for (let i = 0; i < area; i++) {\r\n                    let gr = 17 * ((data[i >> 1] >> (4 - ((i & 1) << 2))) & 15),\r\n                        al = (gr == tr * 17) ? 0 : 255;\r\n                    bf32[i] = (al << 24) | (gr << 16) | (gr << 8) | gr;\r\n                }\r\n            if (depth == 8)\r\n                for (let i = 0; i < area; i++) {\r\n                    let gr = data[i],\r\n                        al = (gr == tr) ? 0 : 255;\r\n                    bf32[i] = (al << 24) | (gr << 16) | (gr << 8) | gr;\r\n                }\r\n            if (depth == 16)\r\n                for (let i = 0; i < area; i++) {\r\n                    let gr = data[i << 1],\r\n                        al = (rs(data, i << 1) == tr) ? 0 : 255;\r\n                    bf32[i] = (al << 24) | (gr << 16) | (gr << 8) | gr;\r\n                }\r\n        }\r\n        return bf;\r\n    }\r\n}\r\n\r\nexport function decodeBuffer(buff) {\r\n    let data = new Uint8Array(buff),\r\n        offset = 8,\r\n        bin = _bin,\r\n        rUs = bin.readUshort,\r\n        rUi = bin.readUint;\r\n    let out = {\r\n        tabs: {},\r\n        frames: [],\r\n        ctype: null,\r\n        data: null,\r\n        width: null,\r\n        height: null,\r\n        compress: null,\r\n        interlace: null,\r\n        filter: null\r\n    };\r\n    let dd = new Uint8Array(data.length),\r\n        doff = 0; // put all IDAT data into it\r\n    let fd: Uint8Array, foff = 0; // frames\r\n    let mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\r\n    for (let i = 0; i < 8; i++)\r\n        if (data[i] != mgck[i]) throw \"The input is not a PNG file!\";\r\n\r\n    while (offset < data.length) {\r\n        let len = bin.readUint(data, offset);\r\n        offset += 4;\r\n        let type = bin.readASCII(data, offset, 4);\r\n        offset += 4;\r\n        //console.log(type,len);\r\n        if (type == \"IHDR\") {\r\n            decode._IHDR(data, offset, out);\r\n        } else if (type == \"IDAT\") {\r\n            for (let i = 0; i < len; i++) dd[doff + i] = data[offset + i];\r\n            doff += len;\r\n        } else if (type == \"acTL\") {\r\n            out.tabs[type] = {\r\n                num_frames: rUi(data, offset),\r\n                num_plays: rUi(data, offset + 4)\r\n            };\r\n            fd = new Uint8Array(data.length);\r\n        } else if (type == \"fcTL\") {\r\n            if (foff != 0) {\r\n                let fr = out.frames[out.frames.length - 1];\r\n                fr.data = decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\r\n                foff = 0;\r\n            }\r\n            let rct = {\r\n                x: rUi(data, offset + 12),\r\n                y: rUi(data, offset + 16),\r\n                width: rUi(data, offset + 4),\r\n                height: rUi(data, offset + 8)\r\n            };\r\n            let del = rUs(data, offset + 22);\r\n            del = rUs(data, offset + 20) / (del == 0 ? 100 : del);\r\n            let frm = {\r\n                rect: rct,\r\n                delay: Math.round(del * 1000),\r\n                dispose: data[offset + 24],\r\n                blend: data[offset + 25]\r\n            };\r\n            //console.log(frm);\r\n            out.frames.push(frm);\r\n        } else if (type == \"fdAT\") {\r\n            for (let i = 0; i < len - 4; i++) fd[foff + i] = data[offset + i + 4];\r\n            foff += len - 4;\r\n        } else if (type == \"pHYs\") {\r\n            out.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset + 4), data[offset + 8]];\r\n        } else if (type == \"cHRM\") {\r\n            out.tabs[type] = [];\r\n            for (let i = 0; i < 8; i++) out.tabs[type].push(bin.readUint(data, offset + i * 4));\r\n        } else if (type == \"tEXt\") {\r\n            if (out.tabs[type] == null) out.tabs[type] = {};\r\n            let nz = bin.nextZero(data, offset);\r\n            let keyw = bin.readASCII(data, offset, nz - offset);\r\n            let text = bin.readASCII(data, nz + 1, offset + len - nz - 1);\r\n            out.tabs[type][keyw] = text;\r\n        } else if (type == \"iTXt\") {\r\n            if (out.tabs[type] == null) out.tabs[type] = {};\r\n            let nz = 0,\r\n                off = offset;\r\n            nz = bin.nextZero(data, off);\r\n            let keyw = bin.readASCII(data, off, nz - off);\r\n            off = nz + 1;\r\n            let cflag = data[off],\r\n                cmeth = data[off + 1];\r\n            off += 2;\r\n            nz = bin.nextZero(data, off);\r\n            var ltag = bin.readASCII(data, off, nz - off);\r\n            off = nz + 1;\r\n            nz = bin.nextZero(data, off);\r\n            let tkeyw = bin.readUTF8(data, off, nz - off);\r\n            off = nz + 1;\r\n            let text = bin.readUTF8(data, off, len - (off - offset));\r\n            out.tabs[type][keyw] = text;\r\n        } else if (type == \"PLTE\") {\r\n            out.tabs[type] = bin.readBytes(data, offset, len);\r\n        } else if (type == \"hIST\") {\r\n            let pl = out.tabs[\"PLTE\"].length / 3;\r\n            out.tabs[type] = [];\r\n            for (let i = 0; i < pl; i++) out.tabs[type].push(rUs(data, offset + i * 2));\r\n        } else if (type == \"tRNS\") {\r\n            if (out.ctype == 3) out.tabs[type] = bin.readBytes(data, offset, len);\r\n            else if (out.ctype == 0) out.tabs[type] = rUs(data, offset);\r\n            else if (out.ctype == 2) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];\r\n            //else console.log(\"tRNS for unsupported color type\",out.ctype, len);\r\n        } else if (type == \"gAMA\") out.tabs[type] = bin.readUint(data, offset) / 100000;\r\n        else if (type == \"sRGB\") out.tabs[type] = data[offset];\r\n        else if (type == \"bKGD\") {\r\n            if (out.ctype == 0 || out.ctype == 4) out.tabs[type] = [rUs(data, offset)];\r\n            else if (out.ctype == 2 || out.ctype == 6) out.tabs[type] = [rUs(data, offset), rUs(data, offset + 2), rUs(data, offset + 4)];\r\n            else if (out.ctype == 3) out.tabs[type] = data[offset];\r\n        } else if (type == \"IEND\") {\r\n            break;\r\n        }\r\n        offset += len;\r\n        let crc = bin.readUint(data, offset);\r\n        offset += 4;\r\n    }\r\n    if (foff != 0) {\r\n        let fr = out.frames[out.frames.length - 1];\r\n        fr.data = decode._decompress(out, fd.slice(0, foff), fr.rect.width, fr.rect.height);\r\n        foff = 0;\r\n    }\r\n    out.data = decode._decompress(out, dd, out.width, out.height);\r\n\r\n    delete out.compress;\r\n    delete out.interlace;\r\n    delete out.filter;\r\n    return out;\r\n}\r\n\r\nclass decode {\r\n\r\n    static _decompress(out, dd, w, h) {\r\n        if (out.compress == 0) dd = decode._inflate(dd);\r\n\r\n        if (out.interlace == 0) dd = decode._filterZero(dd, out, 0, w, h);\r\n        else if (out.interlace == 1) dd = decode._readInterlace(dd, out);\r\n        return dd;\r\n    }\r\n\r\n    static _inflate(data) {\r\n        return pako[\"inflate\"](data);\r\n    }\r\n\r\n    static _readInterlace(data, out) {\r\n        let w = out.width,\r\n            h = out.height;\r\n        let bpp = decode._getBPP(out),\r\n            cbpp = bpp >> 3,\r\n            bpl = Math.ceil(w * bpp / 8);\r\n        let img = new Uint8Array(h * bpl);\r\n        let di = 0;\r\n\r\n        let starting_row = [0, 0, 4, 0, 2, 0, 1];\r\n        let starting_col = [0, 4, 0, 2, 0, 1, 0];\r\n        let row_increment = [8, 8, 8, 4, 4, 2, 2];\r\n        let col_increment = [8, 8, 4, 4, 2, 2, 1];\r\n\r\n        let pass = 0;\r\n        while (pass < 7) {\r\n            let ri = row_increment[pass],\r\n                ci = col_increment[pass];\r\n            let sw = 0,\r\n                sh = 0;\r\n            let cr = starting_row[pass];\r\n            while (cr < h) {\r\n                cr += ri;\r\n                sh++;\r\n            }\r\n            let cc = starting_col[pass];\r\n            while (cc < w) {\r\n                cc += ci;\r\n                sw++;\r\n            }\r\n            let bpll = Math.ceil(sw * bpp / 8);\r\n            decode._filterZero(data, out, di, sw, sh);\r\n\r\n            let y = 0,\r\n                row = starting_row[pass];\r\n            while (row < h) {\r\n                let col = starting_col[pass];\r\n                let cdi = (di + y * bpll) << 3;\r\n\r\n                while (col < w) {\r\n                    if (bpp == 1) {\r\n                        let val = data[cdi >> 3];\r\n                        val = (val >> (7 - (cdi & 7))) & 1;\r\n                        img[row * bpl + (col >> 3)] |= (val << (7 - ((col & 3) << 0)));\r\n                    }\r\n                    if (bpp == 2) {\r\n                        let val = data[cdi >> 3];\r\n                        val = (val >> (6 - (cdi & 7))) & 3;\r\n                        img[row * bpl + (col >> 2)] |= (val << (6 - ((col & 3) << 1)));\r\n                    }\r\n                    if (bpp == 4) {\r\n                        let val = data[cdi >> 3];\r\n                        val = (val >> (4 - (cdi & 7))) & 15;\r\n                        img[row * bpl + (col >> 1)] |= (val << (4 - ((col & 1) << 2)));\r\n                    }\r\n                    if (bpp >= 8) {\r\n                        let ii = row * bpl + col * cbpp;\r\n                        for (let j = 0; j < cbpp; j++) img[ii + j] = data[(cdi >> 3) + j];\r\n                    }\r\n                    cdi += bpp;\r\n                    col += ci;\r\n                }\r\n                y++;\r\n                row += ri;\r\n            }\r\n            if (sw * sh != 0) di += sh * (1 + bpll);\r\n            pass = pass + 1;\r\n        }\r\n        return img;\r\n    }\r\n\r\n    static _getBPP(out) {\r\n        let noc = [1, null, 3, 1, 2, null, 4][out.ctype];\r\n        return noc * out.depth;\r\n    }\r\n\r\n    static _filterZero(data, out, off, w, h) {\r\n        let bpp = decode._getBPP(out),\r\n            bpl = Math.ceil(w * bpp / 8),\r\n            paeth = decode._paeth;\r\n        bpp = Math.ceil(bpp / 8);\r\n\r\n        for (let y = 0; y < h; y++) {\r\n            let i = off + y * bpl,\r\n                di = i + y + 1;\r\n            let type = data[di - 1];\r\n\r\n            if (type == 0)\r\n                for (let x = 0; x < bpl; x++) data[i + x] = data[di + x];\r\n            else if (type == 1) {\r\n                for (let x = 0; x < bpp; x++) data[i + x] = data[di + x];\r\n                for (let x = bpp; x < bpl; x++) data[i + x] = (data[di + x] + data[i + x - bpp]) & 255;\r\n            } else if (y == 0) {\r\n                for (let x = 0; x < bpp; x++) data[i + x] = data[di + x];\r\n                if (type == 2)\r\n                    for (let x = bpp; x < bpl; x++) data[i + x] = (data[di + x]) & 255;\r\n                if (type == 3)\r\n                    for (let x = bpp; x < bpl; x++) data[i + x] = (data[di + x] + (data[i + x - bpp] >> 1)) & 255;\r\n                if (type == 4)\r\n                    for (let x = bpp; x < bpl; x++) data[i + x] = (data[di + x] + paeth(data[i + x - bpp], 0, 0)) & 255;\r\n            } else {\r\n                if (type == 2) {\r\n                    for (let x = 0; x < bpl; x++) data[i + x] = (data[di + x] + data[i + x - bpl]) & 255;\r\n                }\r\n\r\n                if (type == 3) {\r\n                    for (let x = 0; x < bpp; x++) data[i + x] = (data[di + x] + (data[i + x - bpl] >> 1)) & 255;\r\n                    for (let x = bpp; x < bpl; x++) data[i + x] = (data[di + x] + ((data[i + x - bpl] + data[i + x - bpp]) >> 1)) & 255;\r\n                }\r\n\r\n                if (type == 4) {\r\n                    for (let x = 0; x < bpp; x++) data[i + x] = (data[di + x] + paeth(0, data[i + x - bpl], 0)) & 255;\r\n                    for (let x = bpp; x < bpl; x++) data[i + x] = (data[di + x] + paeth(data[i + x - bpp], data[i + x - bpl], data[i + x - bpp - bpl])) & 255;\r\n                }\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n\r\n    static _paeth(a, b, c) {\r\n        let p = a + b - c,\r\n            pa = Math.abs(p - a),\r\n            pb = Math.abs(p - b),\r\n            pc = Math.abs(p - c);\r\n        if (pa <= pb && pa <= pc) return a;\r\n        else if (pb <= pc) return b;\r\n        return c;\r\n    }\r\n\r\n    static _IHDR(data, offset, out) {\r\n        let bin = _bin;\r\n        out.width = bin.readUint(data, offset);\r\n        offset += 4;\r\n        out.height = bin.readUint(data, offset);\r\n        offset += 4;\r\n        out.depth = data[offset];\r\n        offset++;\r\n        out.ctype = data[offset];\r\n        offset++;\r\n        out.compress = data[offset];\r\n        offset++;\r\n        out.filter = data[offset];\r\n        offset++;\r\n        out.interlace = data[offset];\r\n        offset++;\r\n    }\r\n}\r\n\r\n\r\nclass _bin {\r\n    static nextZero(data, p) {\r\n        while (data[p] != 0) p++;\r\n        return p;\r\n    }\r\n\r\n    static readUshort(buff, p) {\r\n        return (buff[p] << 8) | buff[p + 1];\r\n    }\r\n\r\n    static writeUshort(buff, p, n) {\r\n        buff[p] = (n >> 8) & 255;\r\n        buff[p + 1] = n & 255;\r\n    }\r\n\r\n    static readUint(buff, p) {\r\n        return (buff[p] * (256 * 256 * 256)) + ((buff[p + 1] << 16) | (buff[p + 2] << 8) | buff[p + 3]);\r\n    }\r\n\r\n    static writeUint(buff, p, n) {\r\n        buff[p] = (n >> 24) & 255;\r\n        buff[p + 1] = (n >> 16) & 255;\r\n        buff[p + 2] = (n >> 8) & 255;\r\n        buff[p + 3] = n & 255;\r\n    }\r\n\r\n    static readASCII(buff, p, l) {\r\n        let s = \"\";\r\n        for (let i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);\r\n        return s;\r\n    }\r\n\r\n    static writeASCII(data, p, s) {\r\n        for (let i = 0; i < s.length; i++) data[p + i] = s.charCodeAt(i);\r\n    }\r\n\r\n    static readBytes(buff, p, l) {\r\n        let arr = [];\r\n        for (let i = 0; i < l; i++) arr.push(buff[p + i]);\r\n        return arr;\r\n    }\r\n\r\n    static pad(n) {\r\n        return n.length < 2 ? \"0\" + n : n;\r\n    }\r\n\r\n    static readUTF8(buff, p, l) {\r\n        let s = \"\",\r\n            ns;\r\n        for (let i = 0; i < l; i++) s += \"%\" + _bin.pad(buff[p + i].toString(16));\r\n        try {\r\n            ns = decodeURIComponent(s);\r\n        } catch (e) {\r\n            return _bin.readASCII(buff, p, l);\r\n        }\r\n        return ns;\r\n    }\r\n}\r\n\r\nfunction _copyTile(sb, sw, sh, tb, tw, th, xoff, yoff, mode) {\r\n    let w = Math.min(sw, tw),\r\n        h = Math.min(sh, th);\r\n    let si = 0,\r\n        ti = 0;\r\n    for (let y = 0; y < h; y++)\r\n        for (let x = 0; x < w; x++) {\r\n            if (xoff >= 0 && yoff >= 0) {\r\n                si = (y * sw + x) << 2;\r\n                ti = ((yoff + y) * tw + xoff + x) << 2;\r\n            } else {\r\n                si = ((-yoff + y) * sw - xoff + x) << 2;\r\n                ti = (y * tw + x) << 2;\r\n            }\r\n\r\n            if (mode == 0) {\r\n                tb[ti] = sb[si];\r\n                tb[ti + 1] = sb[si + 1];\r\n                tb[ti + 2] = sb[si + 2];\r\n                tb[ti + 3] = sb[si + 3];\r\n            } else if (mode == 1) {\r\n                let fa = sb[si + 3] * (1 / 255),\r\n                    fr = sb[si] * fa,\r\n                    fg = sb[si + 1] * fa,\r\n                    fb = sb[si + 2] * fa;\r\n                let ba = tb[ti + 3] * (1 / 255),\r\n                    br = tb[ti] * ba,\r\n                    bg = tb[ti + 1] * ba,\r\n                    bb = tb[ti + 2] * ba;\r\n\r\n                let ifa = 1 - fa,\r\n                    oa = fa + ba * ifa,\r\n                    ioa = (oa == 0 ? 0 : 1 / oa);\r\n                tb[ti + 3] = 255 * oa;\r\n                tb[ti + 0] = (fr + br * ifa) * ioa;\r\n                tb[ti + 1] = (fg + bg * ifa) * ioa;\r\n                tb[ti + 2] = (fb + bb * ifa) * ioa;\r\n            } else if (mode == 2) { // copy only differences, otherwise zero\r\n                let fa = sb[si + 3],\r\n                    fr = sb[si],\r\n                    fg = sb[si + 1],\r\n                    fb = sb[si + 2];\r\n                let ba = tb[ti + 3],\r\n                    br = tb[ti],\r\n                    bg = tb[ti + 1],\r\n                    bb = tb[ti + 2];\r\n                if (fa == ba && fr == br && fg == bg && fb == bb) {\r\n                    tb[ti] = 0;\r\n                    tb[ti + 1] = 0;\r\n                    tb[ti + 2] = 0;\r\n                    tb[ti + 3] = 0;\r\n                } else {\r\n                    tb[ti] = fr;\r\n                    tb[ti + 1] = fg;\r\n                    tb[ti + 2] = fb;\r\n                    tb[ti + 3] = fa;\r\n                }\r\n            } else if (mode == 3) { // check if can be blended\r\n                let fa = sb[si + 3],\r\n                    fr = sb[si],\r\n                    fg = sb[si + 1],\r\n                    fb = sb[si + 2];\r\n                let ba = tb[ti + 3],\r\n                    br = tb[ti],\r\n                    bg = tb[ti + 1],\r\n                    bb = tb[ti + 2];\r\n                if (fa == ba && fr == br && fg == bg && fb == bb) continue;\r\n                //if(fa!=255 && ba!=0) return false;\r\n                if (fa < 220 && ba > 20) return false;\r\n            }\r\n        }\r\n    return true;\r\n}\r\n\r\n\r\nexport function encodeBuffer(bufs, w, h, ps, dels, forbidPlte) {\r\n    if (ps == null) ps = 0;\r\n    if (forbidPlte == null) forbidPlte = false;\r\n\r\n    let nimg = encode.compress(bufs, w, h, ps, false, forbidPlte);\r\n    encode.compressPNG(nimg, -1);\r\n\r\n    return encode._main(nimg, w, h, dels);\r\n}\r\n\r\nfunction encodeLL(bufs, w, h, cc, ac, depth, dels) {\r\n    let nimg = {\r\n        ctype: 0 + (cc == 1 ? 0 : 2) + (ac == 0 ? 0 : 4),\r\n        depth: depth,\r\n        frames: []\r\n    };\r\n\r\n    let bipp = (cc + ac) * depth,\r\n        bipl = bipp * w;\r\n    for (let i = 0; i < bufs.length; i++) nimg.frames.push({\r\n        rect: {\r\n            x: 0,\r\n            y: 0,\r\n            width: w,\r\n            height: h\r\n        },\r\n        img: new Uint8Array(bufs[i]),\r\n        blend: 0,\r\n        dispose: 1,\r\n        bpp: Math.ceil(bipp / 8),\r\n        bpl: Math.ceil(bipl / 8)\r\n    });\r\n\r\n    encode.compressPNG(nimg, 4);\r\n\r\n    return encode._main(nimg, w, h, dels);\r\n}\r\n\r\nclass encode {\r\n\r\n    static _main(nimg, w, h, dels) {\r\n        let crcFn = crc.crcFn,\r\n            wUi = _bin.writeUint,\r\n            wUs = _bin.writeUshort,\r\n            wAs = _bin.writeASCII;\r\n        let offset = 8,\r\n            anim = nimg.frames.length > 1,\r\n            pltAlpha = false;\r\n\r\n        let leng = 8 + (16 + 5 + 4) + (9 + 4) + (anim ? 20 : 0);\r\n        if (nimg.ctype == 3) {\r\n            let dl = nimg.plte.length;\r\n            for (let i = 0; i < dl; i++)\r\n                if ((nimg.plte[i] >>> 24) != 255) pltAlpha = true;\r\n            leng += (8 + dl * 3 + 4) + (pltAlpha ? (8 + dl * 1 + 4) : 0);\r\n        }\r\n        for (let j = 0; j < nimg.frames.length; j++) {\r\n            let fr = nimg.frames[j];\r\n            if (anim) leng += 38;\r\n            leng += fr.cimg.length + 12;\r\n            if (j != 0) leng += 4;\r\n        }\r\n        leng += 12;\r\n\r\n        let data = new Uint8Array(leng);\r\n        let wr = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\r\n        for (let i = 0; i < 8; i++) data[i] = wr[i];\r\n\r\n        wUi(data, offset, 13);\r\n        offset += 4;\r\n        wAs(data, offset, \"IHDR\");\r\n        offset += 4;\r\n        wUi(data, offset, w);\r\n        offset += 4;\r\n        wUi(data, offset, h);\r\n        offset += 4;\r\n        data[offset] = nimg.depth;\r\n        offset++; // depth\r\n        data[offset] = nimg.ctype;\r\n        offset++; // ctype\r\n        data[offset] = 0;\r\n        offset++; // compress\r\n        data[offset] = 0;\r\n        offset++; // filter\r\n        data[offset] = 0;\r\n        offset++; // interlace\r\n        wUi(data, offset, crcFn(data, offset - 17, 17));\r\n        offset += 4; // crc\r\n        // 9 bytes to say, that it is sRGB\r\n        wUi(data, offset, 1);\r\n        offset += 4;\r\n        wAs(data, offset, \"sRGB\");\r\n        offset += 4;\r\n        data[offset] = 1;\r\n        offset++;\r\n        wUi(data, offset, crcFn(data, offset - 5, 5));\r\n        offset += 4; // crc\r\n        if (anim) {\r\n            wUi(data, offset, 8);\r\n            offset += 4;\r\n            wAs(data, offset, \"acTL\");\r\n            offset += 4;\r\n            wUi(data, offset, nimg.frames.length);\r\n            offset += 4;\r\n            wUi(data, offset, 0);\r\n            offset += 4;\r\n            wUi(data, offset, crcFn(data, offset - 12, 12));\r\n            offset += 4; // crc\r\n        }\r\n\r\n        if (nimg.ctype == 3) {\r\n            let dl = nimg.plte.length;\r\n            wUi(data, offset, dl * 3);\r\n            offset += 4;\r\n            wAs(data, offset, \"PLTE\");\r\n            offset += 4;\r\n            for (let i = 0; i < dl; i++) {\r\n                let ti = i * 3,\r\n                    c = nimg.plte[i],\r\n                    r = (c) & 255,\r\n                    g = (c >>> 8) & 255,\r\n                    b = (c >>> 16) & 255;\r\n                data[offset + ti + 0] = r;\r\n                data[offset + ti + 1] = g;\r\n                data[offset + ti + 2] = b;\r\n            }\r\n            offset += dl * 3;\r\n            wUi(data, offset, crcFn(data, offset - dl * 3 - 4, dl * 3 + 4));\r\n            offset += 4; // crc\r\n            if (pltAlpha) {\r\n                wUi(data, offset, dl);\r\n                offset += 4;\r\n                wAs(data, offset, \"tRNS\");\r\n                offset += 4;\r\n                for (let i = 0; i < dl; i++) data[offset + i] = (nimg.plte[i] >>> 24) & 255;\r\n                offset += dl;\r\n                wUi(data, offset, crcFn(data, offset - dl - 4, dl + 4));\r\n                offset += 4; // crc\r\n            }\r\n        }\r\n\r\n        let fi = 0;\r\n        for (let j = 0; j < nimg.frames.length; j++) {\r\n            let fr = nimg.frames[j];\r\n            if (anim) {\r\n                wUi(data, offset, 26);\r\n                offset += 4;\r\n                wAs(data, offset, \"fcTL\");\r\n                offset += 4;\r\n                wUi(data, offset, fi++);\r\n                offset += 4;\r\n                wUi(data, offset, fr.rect.width);\r\n                offset += 4;\r\n                wUi(data, offset, fr.rect.height);\r\n                offset += 4;\r\n                wUi(data, offset, fr.rect.x);\r\n                offset += 4;\r\n                wUi(data, offset, fr.rect.y);\r\n                offset += 4;\r\n                wUs(data, offset, dels[j]);\r\n                offset += 2;\r\n                wUs(data, offset, 1000);\r\n                offset += 2;\r\n                data[offset] = fr.dispose;\r\n                offset++; // dispose\r\n                data[offset] = fr.blend;\r\n                offset++; // blend\r\n                wUi(data, offset, crcFn(data, offset - 30, 30));\r\n                offset += 4; // crc\r\n            }\r\n\r\n            let imgd = fr.cimg,\r\n                dl = imgd.length;\r\n            wUi(data, offset, dl + (j == 0 ? 0 : 4));\r\n            offset += 4;\r\n            let ioff = offset;\r\n            wAs(data, offset, (j == 0) ? \"IDAT\" : \"fdAT\");\r\n            offset += 4;\r\n            if (j != 0) {\r\n                wUi(data, offset, fi++);\r\n                offset += 4;\r\n            }\r\n            for (let i = 0; i < dl; i++) data[offset + i] = imgd[i];\r\n            offset += dl;\r\n            wUi(data, offset, crcFn(data, ioff, offset - ioff));\r\n            offset += 4; // crc\r\n        }\r\n\r\n        wUi(data, offset, 0);\r\n        offset += 4;\r\n        wAs(data, offset, \"IEND\");\r\n        offset += 4;\r\n        wUi(data, offset, crcFn(data, offset - 4, 4));\r\n        offset += 4; // crc\r\n        return data.buffer;\r\n    }\r\n\r\n    static compressPNG(out, filter) {\r\n        for (let i = 0; i < out.frames.length; i++) {\r\n            let frm = out.frames[i],\r\n                nw = frm.rect.width,\r\n                nh = frm.rect.height;\r\n            let fdata = new Uint8Array(nh * frm.bpl + nh);\r\n            frm.cimg = encode._filterZero(frm.img, nh, frm.bpp, frm.bpl, fdata, filter);\r\n        }\r\n    }\r\n\r\n    static compress(bufs, w, h, ps, forGIF, forbidPlte) {\r\n        //let time = Date.now();\r\n        if (forbidPlte == null) forbidPlte = false;\r\n\r\n        let ctype = 6,\r\n            depth = 8,\r\n            alphaAnd = 255\r\n\r\n        for (let j = 0; j < bufs.length; j++) { // when not quantized, other frames can contain colors, that are not in an initial frame\r\n            let img = new Uint8Array(bufs[j]),\r\n                ilen = img.length;\r\n            for (let i = 0; i < ilen; i += 4) alphaAnd &= img[i + 3];\r\n        }\r\n        let gotAlpha = (alphaAnd != 255);\r\n\r\n        //console.log(\"alpha check\", Date.now()-time);  time = Date.now();\r\n        let brute = gotAlpha && forGIF; // brute : frames can only be copied, not \"blended\"\r\n        let frms = encode.framize(bufs, w, h, forGIF, brute);\r\n        //console.log(\"framize\", Date.now()-time);  time = Date.now();\r\n        let cmap = {},\r\n            plte = [],\r\n            inds = [];\r\n\r\n        if (ps != 0) {\r\n            let nbufs = [];\r\n            for (let i = 0; i < frms.length; i++) nbufs.push(frms[i].img.buffer);\r\n\r\n            let abuf = encode.concatRGBA(nbufs, forGIF),\r\n                qres = quantize.quantizeFN(abuf, ps);\r\n            let cof = 0,\r\n                bb = new Uint8Array(qres.abuf);\r\n            for (let i = 0; i < frms.length; i++) {\r\n                let ti = frms[i].img,\r\n                    bln = ti.length;\r\n                inds.push(new Uint8Array(qres.inds.buffer, cof >> 2, bln >> 2));\r\n                for (let j = 0; j < bln; j += 4) {\r\n                    ti[j] = bb[cof + j];\r\n                    ti[j + 1] = bb[cof + j + 1];\r\n                    ti[j + 2] = bb[cof + j + 2];\r\n                    ti[j + 3] = bb[cof + j + 3];\r\n                }\r\n                cof += bln;\r\n            }\r\n\r\n            for (let i = 0; i < qres.plte.length; i++) plte.push(qres.plte[i].est.rgba);\r\n            //console.log(\"quantize\", Date.now()-time);  time = Date.now();\r\n        } else {\r\n            // what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\r\n            for (let j = 0; j < frms.length; j++) { // when not quantized, other frames can contain colors, that are not in an initial frame\r\n                let frm = frms[j],\r\n                    img32 = new Uint32Array(frm.img.buffer),\r\n                    nw = frm.rect.width,\r\n                    ilen = img32.length;\r\n                let ind = new Uint8Array(ilen);\r\n                inds.push(ind);\r\n                for (let i = 0; i < ilen; i++) {\r\n                    let c = img32[i];\r\n                    if (i != 0 && c == img32[i - 1]) ind[i] = ind[i - 1];\r\n                    else if (i > nw && c == img32[i - nw]) ind[i] = ind[i - nw];\r\n                    else {\r\n                        let cmc = cmap[c];\r\n                        if (cmc == null) {\r\n                            cmap[c] = cmc = plte.length;\r\n                            plte.push(c);\r\n                            if (plte.length >= 300) break;\r\n                        }\r\n                        ind[i] = cmc;\r\n                    }\r\n                }\r\n            }\r\n            //console.log(\"make palette\", Date.now()-time);  time = Date.now();\r\n        }\r\n\r\n        let cc = plte.length; //console.log(\"colors:\",cc);\r\n        if (cc <= 256 && forbidPlte == false) {\r\n            if (cc <= 2) depth = 1;\r\n            else if (cc <= 4) depth = 2;\r\n            else if (cc <= 16) depth = 4;\r\n            else depth = 8;\r\n            if (forGIF) depth = 8;\r\n        }\r\n\r\n        for (let j = 0; j < frms.length; j++) {\r\n            let frm = frms[j],\r\n                nx = frm.rect.x,\r\n                ny = frm.rect.y,\r\n                nw = frm.rect.width,\r\n                nh = frm.rect.height;\r\n            let cimg = frm.img,\r\n                cimg32 = new Uint32Array(cimg.buffer);\r\n            let bpl = 4 * nw,\r\n                bpp = 4;\r\n            if (cc <= 256 && forbidPlte == false) {\r\n                bpl = Math.ceil(depth * nw / 8);\r\n                let nimg = new Uint8Array(bpl * nh);\r\n                let inj = inds[j];\r\n                for (let y = 0; y < nh; y++) {\r\n                    let i = y * bpl,\r\n                        ii = y * nw;\r\n                    if (depth == 8)\r\n                        for (let x = 0; x < nw; x++) nimg[i + (x)] = (inj[ii + x]);\r\n                    else if (depth == 4)\r\n                        for (let x = 0; x < nw; x++) nimg[i + (x >> 1)] |= (inj[ii + x] << (4 - (x & 1) * 4));\r\n                    else if (depth == 2)\r\n                        for (let x = 0; x < nw; x++) nimg[i + (x >> 2)] |= (inj[ii + x] << (6 - (x & 3) * 2));\r\n                    else if (depth == 1)\r\n                        for (let x = 0; x < nw; x++) nimg[i + (x >> 3)] |= (inj[ii + x] << (7 - (x & 7) * 1));\r\n                }\r\n                cimg = nimg;\r\n                ctype = 3;\r\n                bpp = 1;\r\n            } else if (gotAlpha == false && frms.length == 1) { // some next \"reduced\" frames may contain alpha for blending\r\n                let nimg = new Uint8Array(nw * nh * 3),\r\n                    area = nw * nh;\r\n                for (let i = 0; i < area; i++) {\r\n                    let ti = i * 3,\r\n                        qi = i * 4;\r\n                    nimg[ti] = cimg[qi];\r\n                    nimg[ti + 1] = cimg[qi + 1];\r\n                    nimg[ti + 2] = cimg[qi + 2];\r\n                }\r\n                cimg = nimg;\r\n                ctype = 2;\r\n                bpp = 3;\r\n                bpl = 3 * nw;\r\n            }\r\n            frm.img = cimg;\r\n            frm.bpl = bpl;\r\n            frm.bpp = bpp;\r\n        }\r\n        //console.log(\"colors => palette indices\", Date.now()-time);  time = Date.now();\r\n        return {\r\n            ctype: ctype,\r\n            depth: depth,\r\n            plte: plte,\r\n            frames: frms\r\n        };\r\n    }\r\n\r\n    static framize(bufs, w, h, forGIF, brute) {\r\n        let frms = [];\r\n        for (let j = 0; j < bufs.length; j++) {\r\n            let cimg = new Uint8Array(bufs[j]),\r\n                cimg32 = new Uint32Array(cimg.buffer);\r\n\r\n            let nx = 0,\r\n                ny = 0,\r\n                nw = w,\r\n                nh = h,\r\n                blend = 0;\r\n            if (j != 0 && !brute) {\r\n                let tlim = (forGIF || j == 1 || frms[frms.length - 2].dispose == 2) ? 1 : 2,\r\n                    tstp = 0,\r\n                    tarea = 1e9;\r\n                for (let it = 0; it < tlim; it++) {\r\n                    let pimg = new Uint8Array(bufs[j - 1 - it]),\r\n                        p32 = new Uint32Array(bufs[j - 1 - it]);\r\n                    let mix = w,\r\n                        miy = h,\r\n                        max = -1,\r\n                        may = -1;\r\n                    for (let y = 0; y < h; y++)\r\n                        for (let x = 0; x < w; x++) {\r\n                            let i = y * w + x;\r\n                            if (cimg32[i] != p32[i]) {\r\n                                if (x < mix) mix = x;\r\n                                if (x > max) max = x;\r\n                                if (y < miy) miy = y;\r\n                                if (y > may) may = y;\r\n                            }\r\n                        }\r\n                    let sarea = (max == -1) ? 1 : (max - mix + 1) * (may - miy + 1);\r\n                    if (sarea < tarea) {\r\n                        tarea = sarea;\r\n                        tstp = it;\r\n                        if (max == -1) {\r\n                            nx = ny = 0;\r\n                            nw = nh = 1;\r\n                        } else {\r\n                            nx = mix;\r\n                            ny = miy;\r\n                            nw = max - mix + 1;\r\n                            nh = may - miy + 1;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let pimg = new Uint8Array(bufs[j - 1 - tstp]);\r\n                if (tstp == 1) frms[frms.length - 1].dispose = 2;\r\n\r\n                let nimg = new Uint8Array(nw * nh * 4),\r\n                    nimg32 = new Uint32Array(nimg.buffer);\r\n                _copyTile(pimg, w, h, nimg, nw, nh, -nx, -ny, 0);\r\n                if (_copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 3)) {\r\n                    _copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 2);\r\n                    blend = 1;\r\n                } else {\r\n                    _copyTile(cimg, w, h, nimg, nw, nh, -nx, -ny, 0);\r\n                    blend = 0;\r\n                }\r\n                cimg = nimg;\r\n            } else cimg = cimg.slice(0); // img may be rewrited further ... don't rewrite input\r\n            frms.push({\r\n                rect: {\r\n                    x: nx,\r\n                    y: ny,\r\n                    width: nw,\r\n                    height: nh\r\n                },\r\n                img: cimg,\r\n                blend: blend,\r\n                dispose: brute ? 1 : 0\r\n            });\r\n        }\r\n        return frms;\r\n    }\r\n\r\n    static _filterZero(img, h, bpp, bpl, data, filter) {\r\n        if (filter != -1) {\r\n            for (let y = 0; y < h; y++) encode._filterLine(data, img, y, bpl, bpp, filter);\r\n            return pako[\"deflate\"](data);\r\n        }\r\n        let fls = [];\r\n        for (let t = 0; t < 5; t++) {\r\n            if (h * bpl > 500000 && (t == 2 || t == 3 || t == 4)) continue;\r\n            for (let y = 0; y < h; y++) encode._filterLine(data, img, y, bpl, bpp, t);\r\n            fls.push(pako[\"deflate\"](data));\r\n            if (bpp == 1) break;\r\n        }\r\n        let ti, tsize = 1e9;\r\n        for (let i = 0; i < fls.length; i++)\r\n            if (fls[i].length < tsize) {\r\n                ti = i;\r\n                tsize = fls[i].length;\r\n            }\r\n        return fls[ti];\r\n    }\r\n\r\n    static _filterLine(data: Array<number>, img: Array<number>, y: number, bpl: number, bpp: number, type: number) {\r\n        let i = y * bpl,\r\n            di = i + y,\r\n            paeth = decode._paeth;\r\n        data[di] = type;\r\n        di++;\r\n\r\n        if (type == 0)\r\n            for (let x = 0; x < bpl; x++) data[di + x] = img[i + x];\r\n        else if (type == 1) {\r\n            for (let x = 0; x < bpp; x++) data[di + x] = img[i + x];\r\n            for (let x = bpp; x < bpl; x++) data[di + x] = (img[i + x] - img[i + x - bpp] + 256) & 255;\r\n        } else if (y == 0) {\r\n            for (let x = 0; x < bpp; x++) data[di + x] = img[i + x];\r\n\r\n            if (type == 2)\r\n                for (let x = bpp; x < bpl; x++) data[di + x] = img[i + x];\r\n            if (type == 3)\r\n                for (let x = bpp; x < bpl; x++) data[di + x] = (img[i + x] - (img[i + x - bpp] >> 1) + 256) & 255;\r\n            if (type == 4)\r\n                for (let x = bpp; x < bpl; x++) data[di + x] = (img[i + x] - paeth(img[i + x - bpp], 0, 0) + 256) & 255;\r\n        } else {\r\n            if (type == 2) {\r\n                for (let x = 0; x < bpl; x++) data[di + x] = (img[i + x] + 256 - img[i + x - bpl]) & 255;\r\n            }\r\n            if (type == 3) {\r\n                for (let x = 0; x < bpp; x++) data[di + x] = (img[i + x] + 256 - (img[i + x - bpl] >> 1)) & 255;\r\n                for (let x = bpp; x < bpl; x++) data[di + x] = (img[i + x] + 256 - ((img[i + x - bpl] + img[i + x - bpp]) >> 1)) & 255;\r\n            }\r\n            if (type == 4) {\r\n                for (let x = 0; x < bpp; x++) data[di + x] = (img[i + x] + 256 - paeth(0, img[i + x - bpl], 0)) & 255;\r\n                for (let x = bpp; x < bpl; x++) data[di + x] = (img[i + x] + 256 - paeth(img[i + x - bpp], img[i + x - bpl], img[i + x - bpp - bpl])) & 255;\r\n            }\r\n        }\r\n    }\r\n\r\n    static concatRGBA(bufs, roundAlpha) {\r\n        let tlen = 0;\r\n        for (let i = 0; i < bufs.length; i++) tlen += bufs[i].byteLength;\r\n        let nimg = new Uint8Array(tlen),\r\n            noff = 0;\r\n        for (let i = 0; i < bufs.length; i++) {\r\n            let img = new Uint8Array(bufs[i]),\r\n                il = img.length;\r\n            for (let j = 0; j < il; j += 4) {\r\n                let r = img[j],\r\n                    g = img[j + 1],\r\n                    b = img[j + 2],\r\n                    a = img[j + 3];\r\n                if (roundAlpha) a = (a & 128) == 0 ? 0 : 255;\r\n                if (a == 0) r = g = b = 0;\r\n                nimg[noff + j] = r;\r\n                nimg[noff + j + 1] = g;\r\n                nimg[noff + j + 2] = b;\r\n                nimg[noff + j + 3] = a;\r\n            }\r\n            noff += il;\r\n        }\r\n        return nimg.buffer;\r\n    }\r\n\r\n}\r\n\r\n\r\nclass crc {\r\n    static crcFn(b: Uint8Array, o: number, l: number) {\r\n        return crc.update(0xffffffff, b, o, l) ^ 0xffffffff;\r\n    }\r\n\r\n    static table() {\r\n        let tab = new Uint32Array(256);\r\n        for (let n = 0; n < 256; n++) {\r\n            let c = n;\r\n            for (let k = 0; k < 8; k++) {\r\n                if (c & 1) c = 0xedb88320 ^ (c >>> 1);\r\n                else c = c >>> 1;\r\n            }\r\n            tab[n] = c;\r\n        }\r\n        return tab;\r\n    }\r\n\r\n    static update(c: number, buf: Uint8Array, off: number, len: number) {\r\n        for (let i = 0; i < len; i++) c = crc.table[(c ^ buf[off + i]) & 0xff] ^ (c >>> 8);\r\n        return c;\r\n    }\r\n}\r\n\r\nclass quantize {\r\n    static quantizeFN(abuf, ps) {\r\n        let oimg = new Uint8Array(abuf),\r\n            nimg = oimg.slice(0),\r\n            nimg32 = new Uint32Array(nimg.buffer);\r\n\r\n        let KD = quantize.getKDtree(nimg, ps);\r\n        let {root, leafs} = KD;\r\n\r\n        let planeDst = quantize.planeDst;\r\n        let sb = oimg,\r\n            tb = nimg32,\r\n            len = sb.length;\r\n\r\n        let inds = new Uint8Array(oimg.length >> 2);\r\n        for (let i = 0; i < len; i += 4) {\r\n            let r = sb[i] * (1 / 255),\r\n                g = sb[i + 1] * (1 / 255),\r\n                b = sb[i + 2] * (1 / 255),\r\n                a = sb[i + 3] * (1 / 255);\r\n\r\n            //  exact, but too slow :(\r\n            let nd = quantize.getNearest(root, r, g, b, a);\r\n            //let nd = root;\r\n            //while(nd.left) nd = (planeDst(nd.est,r,g,b,a)<=0) ? nd.left : nd.right;\r\n            inds[i >> 2] = nd.ind;\r\n            tb[i >> 2] = nd.est.rgba;\r\n        }\r\n        return {\r\n            abuf: nimg.buffer,\r\n            inds: inds,\r\n            plte: leafs\r\n        };\r\n    }\r\n\r\n    static getKDtree(nimg, ps, err?) {\r\n        if (err == null) err = 0.0001;\r\n        let nimg32 = new Uint32Array(nimg.buffer);\r\n\r\n        let root = {\r\n            i0: 0,\r\n            i1: nimg.length,\r\n            bst: null,\r\n            est: null,\r\n            tdst: 0,\r\n            left: null,\r\n            right: null,\r\n            //ind: null\r\n            ind: null\r\n        }; // basic statistic, extra statistic\r\n        root.bst = quantize.stats(nimg, root.i0, root.i1);\r\n        root.est = quantize.estats(root.bst);\r\n        let leafs = [root];\r\n\r\n        while (leafs.length < ps) {\r\n            let maxL = 0,\r\n                mi = 0;\r\n            for (let i = 0; i < leafs.length; i++)\r\n                if (leafs[i].est.L > maxL) {\r\n                    maxL = leafs[i].est.L;\r\n                    mi = i;\r\n                }\r\n            if (maxL < err) break;\r\n            let node = leafs[mi];\r\n\r\n            let s0 = quantize.splitPixels(nimg, nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\r\n            let s0wrong = (node.i0 >= s0 || node.i1 <= s0);\r\n            //console.log(maxL, leafs.length, mi);\r\n            if (s0wrong) {\r\n                node.est.L = 0;\r\n                continue;\r\n            }\r\n\r\n            let ln = {\r\n                i0: node.i0,\r\n                i1: s0,\r\n                bst: null,\r\n                est: null,\r\n                tdst: 0,\r\n                left: null,\r\n                right: null,\r\n                ind: null\r\n            };\r\n            ln.bst = quantize.stats(nimg, ln.i0, ln.i1);\r\n            ln.est = quantize.estats(ln.bst);\r\n            let rn = {\r\n                i0: s0,\r\n                i1: node.i1,\r\n                bst: null,\r\n                est: null,\r\n                tdst: 0,\r\n                left: null,\r\n                right: null,\r\n                ind: null\r\n            };\r\n            rn.bst = {\r\n                R: [],\r\n                m: [],\r\n                N: node.bst.N - ln.bst.N\r\n            };\r\n            for (let i = 0; i < 16; i++) rn.bst.R[i] = node.bst.R[i] - ln.bst.R[i];\r\n            for (let i = 0; i < 4; i++) rn.bst.m[i] = node.bst.m[i] - ln.bst.m[i];\r\n            rn.est = quantize.estats(rn.bst);\r\n\r\n            node.left = ln;\r\n            node.right = rn;\r\n            leafs[mi] = ln;\r\n            leafs.push(rn);\r\n        }\r\n        leafs.sort(function (a, b) {\r\n            return b.bst.N - a.bst.N;\r\n        });\r\n        for (let i = 0; i < leafs.length; i++) leafs[i].ind = i;\r\n        return {root, leafs};\r\n    }\r\n\r\n\r\n    static getNearest(nd, r, g, b, a) {\r\n        if (nd.left == null) {\r\n            nd.tdst = quantize.dist(nd.est.q, r, g, b, a);\r\n            return nd;\r\n        }\r\n        let planeDst = quantize.planeDst(nd.est, r, g, b, a);\r\n\r\n        let node0 = nd.left,\r\n            node1 = nd.right;\r\n        if (planeDst > 0) {\r\n            node0 = nd.right;\r\n            node1 = nd.left;\r\n        }\r\n\r\n        let ln = quantize.getNearest(node0, r, g, b, a);\r\n        if (ln.tdst <= planeDst * planeDst) return ln;\r\n        let rn = quantize.getNearest(node1, r, g, b, a);\r\n        return rn.tdst < ln.tdst ? rn : ln;\r\n    }\r\n\r\n    static planeDst(est, r, g, b, a) {\r\n        let e = est.e;\r\n        return e[0] * r + e[1] * g + e[2] * b + e[3] * a - est.eMq;\r\n    }\r\n\r\n    static dist(q, r, g, b, a) {\r\n        let d0 = r - q[0],\r\n            d1 = g - q[1],\r\n            d2 = b - q[2],\r\n            d3 = a - q[3];\r\n        return d0 * d0 + d1 * d1 + d2 * d2 + d3 * d3;\r\n    }\r\n\r\n    static splitPixels(nimg, nimg32, i0, i1, e, eMq) {\r\n        let vecDot = quantize.vecDot;\r\n        i1 -= 4;\r\n        let shfs = 0;\r\n        while (i0 < i1) {\r\n            while (vecDot(nimg, i0, e) <= eMq) i0 += 4;\r\n            while (vecDot(nimg, i1, e) > eMq) i1 -= 4;\r\n            if (i0 >= i1) break;\r\n\r\n            let t = nimg32[i0 >> 2];\r\n            nimg32[i0 >> 2] = nimg32[i1 >> 2];\r\n            nimg32[i1 >> 2] = t;\r\n\r\n            i0 += 4;\r\n            i1 -= 4;\r\n        }\r\n        while (vecDot(nimg, i0, e) > eMq) i0 -= 4;\r\n        return i0 + 4;\r\n    }\r\n\r\n    static vecDot(nimg, i, e) {\r\n        return nimg[i] * e[0] + nimg[i + 1] * e[1] + nimg[i + 2] * e[2] + nimg[i + 3] * e[3];\r\n    }\r\n\r\n    static stats(nimg, i0, i1) {\r\n        let R = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\r\n        let m = [0, 0, 0, 0];\r\n        let N = (i1 - i0) >> 2;\r\n        for (let i = i0; i < i1; i += 4) {\r\n            let r = nimg[i] * (1 / 255),\r\n                g = nimg[i + 1] * (1 / 255),\r\n                b = nimg[i + 2] * (1 / 255),\r\n                a = nimg[i + 3] * (1 / 255);\r\n            //let r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\r\n            m[0] += r;\r\n            m[1] += g;\r\n            m[2] += b;\r\n            m[3] += a;\r\n\r\n            R[0] += r * r;\r\n            R[1] += r * g;\r\n            R[2] += r * b;\r\n            R[3] += r * a;\r\n            R[5] += g * g;\r\n            R[6] += g * b;\r\n            R[7] += g * a;\r\n            R[10] += b * b;\r\n            R[11] += b * a;\r\n            R[15] += a * a;\r\n        }\r\n        R[4] = R[1];\r\n        R[8] = R[2];\r\n        R[9] = R[6];\r\n        R[12] = R[3];\r\n        R[13] = R[7];\r\n        R[14] = R[11];\r\n\r\n        return {\r\n            R: R,\r\n            m: m,\r\n            N: N\r\n        };\r\n    }\r\n\r\n    static estats(stats) {\r\n        let R = stats.R,\r\n            m = stats.m,\r\n            N = stats.N;\r\n\r\n        // when all samples are equal, but N is large (millions), the Rj can be non-zero ( 0.0003.... - precission error)\r\n        let m0 = m[0],\r\n            m1 = m[1],\r\n            m2 = m[2],\r\n            m3 = m[3],\r\n            iN = (N == 0 ? 0 : 1 / N);\r\n        let Rj = [R[0] - m0 * m0 * iN, R[1] - m0 * m1 * iN, R[2] - m0 * m2 * iN, R[3] - m0 * m3 * iN, R[4] - m1 * m0 * iN, R[5] - m1 * m1 * iN, R[6] - m1 * m2 * iN, R[7] - m1 * m3 * iN, R[8] - m2 * m0 * iN, R[9] - m2 * m1 * iN, R[10] - m2 * m2 * iN, R[11] - m2 * m3 * iN, R[12] - m3 * m0 * iN, R[13] - m3 * m1 * iN, R[14] - m3 * m2 * iN, R[15] - m3 * m3 * iN];\r\n\r\n        let A = Rj,\r\n            M = M4;\r\n        let b = [0.5, 0.5, 0.5, 0.5],\r\n            mi = 0,\r\n            tmi = 0;\r\n\r\n        if (N != 0)\r\n            for (let i = 0; i < 10; i++) {\r\n                b = M.multVec(A, b);\r\n                tmi = Math.sqrt(M.dot(b, b));\r\n                b = M.sml(1 / tmi, b);\r\n                if (Math.abs(tmi - mi) < 1e-9) break;\r\n                mi = tmi;\r\n            }\r\n        //b = [0,0,1,0];  mi=N;\r\n        let q = [m0 * iN, m1 * iN, m2 * iN, m3 * iN];\r\n        let eMq255 = M.dot(M.sml(255, q), b);\r\n\r\n        return {\r\n            Cov: Rj,\r\n            q: q,\r\n            e: b,\r\n            L: mi,\r\n            eMq255: eMq255,\r\n            eMq: M.dot(b, q),\r\n            rgba: (((Math.round(255 * q[3]) << 24) | (Math.round(255 * q[2]) << 16) | (Math.round(255 * q[1]) << 8) | (Math.round(255 * q[0]) << 0)) >>> 0)\r\n        };\r\n    }\r\n}\r\n\r\n\r\nclass M4 {\r\n    static multVec(m, v) {\r\n        return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * v[3], m[4] * v[0] + m[5] * v[1] + m[6] * v[2] + m[7] * v[3], m[8] * v[0] + m[9] * v[1] + m[10] * v[2] + m[11] * v[3], m[12] * v[0] + m[13] * v[1] + m[14] * v[2] + m[15] * v[3]];\r\n    }\r\n\r\n    static dot(x, y) {\r\n        return x[0] * y[0] + x[1] * y[1] + x[2] * y[2] + x[3] * y[3];\r\n    }\r\n\r\n    static sml(a, y) {\r\n        return [a * y[0], a * y[1], a * y[2], a * y[3]];\r\n    }\r\n}\r\n\r\n\r\n\r\n","import {$getExeName}  from './lib/_getExeName'        // \r\nimport {$omggif} from './lib/_omggif'                // gif\r\nimport { decodeBuffer, uPng } from './lib/_upng'\r\nimport {Ticker} from '@pixi/ticker';\r\nimport {Sprite} from '@pixi/sprite';\r\nimport {BaseTexture, Texture} from '@pixi/core';\r\nimport {Rectangle} from '@pixi/math';                  // png\r\n\r\nclass Image{\r\n    private esource: any;\r\n    private resources: any;\r\n    private temp: {\r\n        tickerIsAdd?: Boolean;\r\n        loop?: any;\r\n        events: {} };\r\n    private __method: { play: (loop, callback) => void };\r\n    private __attr: { loop: number; autoPlay: boolean };\r\n    private __status: { loops: number; time: number; status: string; frame: number };\r\n    private ticker: Ticker;\r\n    private sprite: Sprite;\r\n    private textures: any;\r\n    private framesDelay: any;\r\n    constructor(esource,resources){\r\n        this.esource = esource;\r\n        this.resources = resources;\r\n\r\n        this.init();\r\n    }\r\n\r\n    init(){\r\n        this.temp = {                                        // \r\n            //loop:0,                                       // \r\n            //tickerIsAdd:undefined                         // \r\n            events:{}                                       // \r\n        };\r\n\r\n        // \r\n        this.__attr = {\r\n            autoPlay:true,     // \r\n            loop:0             // \r\n        };\r\n\r\n        // \r\n        this.__method = {\r\n            play:this.play       // \r\n        };\r\n\r\n        // \r\n        this.__status = {\r\n            status:'init',      // initplayingplayedpausestop\r\n            frame:0,            // \r\n            loops:0,            // 0\r\n            time:0\r\n        };\r\n        \r\n        // \r\n        this.ticker = new Ticker();\r\n        this.ticker.stop();\r\n\r\n        // \r\n        this.sprite = this.createSprite(this.esource,this.resources);\r\n    }\r\n\r\n    // \r\n    play(loop?,callback?){\r\n        // \r\n        if(!this.textures.length){\r\n            throw new Error('textures');\r\n        }\r\n\r\n        // \r\n        if(this.textures.length === 1){\r\n            return;\r\n        }\r\n\r\n        let status = this.__status,\r\n            attr = this.__attr,\r\n            time = 0;\r\n\r\n        // 0\r\n        if(status.status === 'stop'){\r\n            status.loops = 0;\r\n        }\r\n\r\n        // \r\n        loop = typeof loop === 'number' ? loop : attr.loop;\r\n        this.temp.loop = loop;\r\n        attr.loop = loop;\r\n        \r\n        // \r\n        if(!this.temp.tickerIsAdd){\r\n            this.ticker.add(deltaTime => {\r\n                let elapsed = Ticker.shared.elapsedMS;\r\n                time+=elapsed;\r\n\r\n                // \r\n                if(time > this.framesDelay[status.frame]){\r\n                    status.frame++;\r\n\r\n                    // \r\n                    status.status = 'playing';\r\n    \r\n                    // 0\r\n                    if(status.frame > this.textures.length - 1){\r\n                        status.frame = 0;\r\n                        status.loops++;\r\n    \r\n                        // \r\n                        if(this.temp.loop > 0 && status.loops >= this.temp.loop){\r\n                            if(typeof callback === 'function'){\r\n                                callback(status);\r\n                            };\r\n                            // \r\n                            status.status = 'played';\r\n                            this.runEvent('played',status);\r\n                            this.stop();\r\n                        }\r\n                    }\r\n    \r\n                    // \r\n                    this.sprite.texture = this.textures[status.frame];\r\n                    time = 0;\r\n\r\n                    this.runEvent('playing',status);\r\n                }\r\n            });\r\n            this.temp.tickerIsAdd = true;\r\n        }\r\n        \r\n        // \r\n        this.ticker.start();\r\n    }\r\n\r\n    // \r\n    pause(){\r\n        const _ts = this,\r\n            status = _ts.__status;\r\n        _ts.ticker.stop();\r\n        status.status = 'pause';\r\n        _ts.runEvent('pause',status);\r\n    }\r\n\r\n    // \r\n    stop(){\r\n        const _ts = this,\r\n            status = _ts.__status;\r\n        _ts.ticker.stop();\r\n        status.status = 'stop'; \r\n        _ts.runEvent('stop',status);\r\n    }\r\n\r\n    // \r\n    jumpToFrame(frameIndex){\r\n        const _ts = this,\r\n            textures = _ts.textures;\r\n\r\n        // \r\n        if(!textures.length){\r\n            throw new Error('textures');\r\n        }\r\n\r\n        let status = _ts.__status;\r\n\r\n        frameIndex = frameIndex < 0 ? 0 : frameIndex > textures.length - 1 ? textures.length - 1 : frameIndex;\r\n\r\n        if(typeof frameIndex === 'number'){\r\n            _ts.sprite.texture = textures[frameIndex];\r\n            status.frame = frameIndex;\r\n        }\r\n    }\r\n\r\n    // \r\n    getDuration(){\r\n        const framesDelay = this.framesDelay;\r\n        \r\n        // \r\n        if(!framesDelay.length){\r\n            throw new Error('');\r\n        }\r\n\r\n        let time = 0;\r\n\r\n        for(let i=0,len=framesDelay.length; i<len; i++){\r\n            time += framesDelay[i];\r\n        }\r\n        return time;\r\n    }\r\n\r\n    // \r\n    getFramesLength(){\r\n        const _ts = this;\r\n        // \r\n        if(!_ts.textures.length){\r\n            throw new Error('textures');\r\n        };\r\n        return _ts.textures.length;\r\n    }\r\n\r\n    // \r\n    on(type,fun){\r\n        const _ts = this;\r\n\r\n        switch (type) {\r\n            case 'playing':\r\n            case 'played':\r\n            case 'pause':\r\n            case 'stop':\r\n                _ts.temp.events[type] = fun;\r\n            break;\r\n            default:\r\n                throw new Error('');\r\n            break;\r\n        }\r\n    }\r\n\r\n    runEvent(type,status){\r\n        let temp = this.temp;\r\n        if(typeof temp.events[type] === 'function'){\r\n            temp.events[type](status);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param  {array:string}} imgSrc \r\n     * @param  {object} resources \r\n     * @return {object} \r\n     */\r\n    createSprite(esource,resources){\r\n        const _ts = this;\r\n\r\n        let\r\n            \r\n            imgSrc = esource,\r\n            exeName = $getExeName(imgSrc.toLocaleLowerCase());\r\n        \r\n        // gifpngother\r\n        exeName = exeName === 'gif' || exeName === 'png' ? exeName : 'other';\r\n\r\n        let funs = {\r\n            'gif':()=>{\r\n                let gifDecodeData = _ts.gifResourceToTextures(resources[imgSrc]);\r\n                _ts.textures = gifDecodeData.textures;\r\n                _ts.framesDelay = gifDecodeData.delayTimes;\r\n                _ts.play();\r\n\r\n                // \r\n                return new Sprite(_ts.textures[0]);\r\n            },\r\n            'png':()=>{\r\n                let pngDecodeData = _ts.apngResourceToTextures(resources[imgSrc]);\r\n                _ts.textures = pngDecodeData.textures;\r\n                _ts.framesDelay = pngDecodeData.delayTimes;\r\n                _ts.play();\r\n\r\n                // \r\n                return new Sprite(_ts.textures[0]);\r\n            },\r\n            'other':()=>{\r\n                _ts.textures = [resources[imgSrc].texture];\r\n                return new Sprite(resources[imgSrc].texture);\r\n            }\r\n        };\r\n        return funs[exeName]();\r\n    }\r\n\r\n    /**\r\n     * apng\r\n     * @param  {object} resource    \r\n     * @return {object} apng\r\n     */\r\n    apngResourceToTextures(resource){\r\n        const _ts = this;\r\n\r\n        let obj = {\r\n                delayTimes:[],\r\n                textures:[]\r\n            },\r\n            buf = new Uint8Array(resource.data),\r\n            upng = decodeBuffer(buf),\r\n            rgba = uPng(upng),\r\n            pngWidth = upng.width,\r\n            pngHeight = upng.height,\r\n            pngFramesLen = upng.frames.length,\r\n            \r\n            spriteSheet,\r\n            canvas,\r\n            ctx,\r\n            imageData;\r\n\r\n        \r\n        \r\n        // \r\n        upng.frames.forEach((item,index)=>{\r\n            obj.delayTimes.push(item.delay);\r\n        });\r\n\r\n        for(let i=0,len=rgba.length; i<len; i++){\r\n            let item = rgba[i],\r\n                data = new Uint8ClampedArray(item);\r\n            \r\n            canvas = document.createElement('canvas');\r\n            canvas.width = pngWidth;\r\n            canvas.height = pngHeight;\r\n            ctx = canvas.getContext('2d');\r\n            spriteSheet = BaseTexture.from(canvas);\r\n            \r\n            imageData = ctx.createImageData(pngWidth,pngHeight);\r\n            imageData.data.set(data);\r\n            ctx.putImageData(imageData,0,0);\r\n\r\n            obj.textures.push(new Texture(spriteSheet,new Rectangle(0, 0, pngWidth, pngHeight)));\r\n        }\r\n\r\n        // document.body.appendChild(canvas);\r\n        return obj;\r\n    }\r\n\r\n    /**\r\n     * gif\r\n     * @param  {object} resource    \r\n     * @return {object} apng\r\n     */\r\n    gifResourceToTextures(resource){\r\n        const _ts = this;\r\n\r\n        let obj = {\r\n                delayTimes:[],\r\n                textures:[]\r\n            },\r\n            buf = new Uint8Array(resource.data),\r\n            gif = new $omggif(buf),\r\n            gifWidth = gif.width,\r\n            gifHeight = gif.height,\r\n            gifFramesLen = gif.numFrames(),\r\n            gifFrameInfo,\r\n            \r\n            spriteSheet,\r\n            canvas,\r\n            ctx,\r\n            imageData;\r\n        \r\n        \r\n\r\n        for(let i=0; i<gifFramesLen; i++){\r\n            //\r\n            gifFrameInfo = gif.frameInfo(i);\r\n            obj.delayTimes.push(gifFrameInfo.delay * 10);\r\n\r\n            canvas = document.createElement('canvas');\r\n            canvas.width = gifWidth;\r\n            canvas.height = gifHeight;\r\n            ctx = canvas.getContext('2d');\r\n\r\n            //ImageData\r\n            imageData = ctx.createImageData(gifWidth, gifHeight);\r\n\r\n            //RGBA\r\n            gif.decodeAndBlitFrameRGBA(i,imageData.data);\r\n\r\n            //\r\n            ctx.putImageData(imageData, 0, 0);\r\n\r\n            spriteSheet = BaseTexture.from(canvas);\r\n            obj.textures.push(new Texture(spriteSheet,new Rectangle(0, 0, gifWidth, gifHeight)));\r\n        };\r\n        // document.body.appendChild(canvas);\r\n        return obj;\r\n    }\r\n}\r\n\r\nexport default Image;\r\n","export function $getExeName(filePath: string) {\r\n    let aList = filePath.split('.');\r\n    return aList[aList.length - 1];\r\n}\r\n"],"names":["GifReader","buf","frames","loop_count","width","height","this","p","Error","pf0","num_global_colors","global_palette_offset","global_palette_size","no_eof","delay","transparent_index","disposal","length","block_size","pf1","toString","x","y","w","h","pf2","interlace_flag","num_local_colors","palette_offset","palette_size","has_local_palette","data_offset","push","data_length","interlaced","numFrames","loopCount","frameInfo","frame_num","decodeAndBlitFrameBGRA","pixels","frame","num_pixels","index_stream","Uint8Array","GifReaderLZWOutputIndexStream","trans","framewidth","framestride","xleft","opbeg","opend","op","scanstride","interlaceskip","i","il","index","r","g","decodeAndBlitFrameRGBA","b","code_stream","output","output_length","min_code_size","clear_code","eoi_code","next_code","cur_code_size","code_mask","cur_shift","cur","subblock_size","code_table","Int32Array","prev_code","code","chase_code","chase_length","chase","k","console","log","prototype","slice","subarray","toRGBA8","decodeImage","data","out","area","bpp","decode","_getBPP","bpl","Math","ceil","bf","bf32","Uint32Array","buffer","ctype","depth","rs","_bin","readUshort","qarea","ts","tabs","tr","tg","tb","qi","ti","ap","tl","s0","t0","j","cj","di","gr","al","_decompress","dd","compress","_inflate","interlace","_filterZero","_readInterlace","pako","cbpp","img","starting_row","starting_col","row_increment","col_increment","pass","ri","ci","sw","sh","cr","cc","bpll","row","col","cdi","val","ii","off","paeth","_paeth","type","a","c","pa","abs","pb","pc","_IHDR","offset","bin","readUint","filter","nextZero","buff","writeUshort","n","writeUint","readASCII","l","s","String","fromCharCode","writeASCII","charCodeAt","readBytes","arr","pad","readUTF8","ns","decodeURIComponent","e","_copyTile","sb","tw","th","xoff","yoff","mode","min","si","fa","fr","fg","fb","ba","br","bg","bb","ifa","oa","ioa","Image","esource","resources","temp","__method","__attr","__status","ticker","sprite","textures","framesDelay","init","events","autoPlay","loop","play","status","loops","time","Ticker","stop","createSprite","callback","attr","tickerIsAdd","add","deltaTime","shared","elapsedMS","_this","runEvent","texture","start","pause","_ts","jumpToFrame","frameIndex","getDuration","len","getFramesLength","on","fun","aList","imgSrc","exeName","toLocaleLowerCase","split","gif","gifDecodeData","gifResourceToTextures","delayTimes","Sprite","png","pngDecodeData","apngResourceToTextures","other","resource","obj","spriteSheet","canvas","ctx","imageData","upng","fd","rUs","rUi","doff","foff","mgck","num_frames","num_plays","rect","rct","del","frm","round","dispose","blend","nz","keyw","text","pl","decodeBuffer","rgba","acTL","frms","empty","fx","fy","fw","fh","fdata","pi","uPng","pngWidth","pngHeight","forEach","item","Uint8ClampedArray","document","createElement","getContext","BaseTexture","from","createImageData","set","putImageData","Texture","Rectangle","gifFrameInfo","$omggif","gifWidth","gifHeight","gifFramesLen"],"mappings":"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"}